<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake Game (Controller Support)</title>
<style>
  body {
    background: black;
    margin: 0;
    color: white;
    font-family: Consolas, monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
  }
  canvas {
    background: black;
    display: block;
    border: 2px solid white;
  }
  button {
    background: #222;
    color: white;
    border: 1px solid #555;
    padding: 6px 12px;
    margin: 8px;
    font-family: inherit;
    cursor: pointer;
  }
  button:hover {
    background: #333;
  }
</style>
</head>
<body>

<button id="toggleMode">Mode: Wrap Around</button>
<canvas id="game"></canvas>

<script>
const CELL_SIZE = 20;
const GRID_WIDTH = 32;
const GRID_HEIGHT = 24;
const FPS = 12;

const canvas = document.getElementById("game");
canvas.width = CELL_SIZE * GRID_WIDTH;
canvas.height = CELL_SIZE * GRID_HEIGHT;
const ctx = canvas.getContext("2d");

let snake, direction, nextDirection, food, score, gameOver, paused;
let wrapMode = true; // true = wrap around, false = walls kill

document.getElementById("toggleMode").addEventListener("click", () => {
  wrapMode = !wrapMode;
  document.getElementById("toggleMode").textContent =
    `Mode: ${wrapMode ? "Wrap Around" : "Walls Kill"}`;
  resetGame();
});

function resetGame() {
  const startX = Math.floor(GRID_WIDTH / 2);
  const startY = Math.floor(GRID_HEIGHT / 2);
  snake = [
    {x: startX, y: startY},
    {x: startX - 1, y: startY},
    {x: startX - 2, y: startY}
  ];
  direction = {x: 1, y: 0};
  nextDirection = {x: 1, y: 0};
  food = randomFood();
  score = 0;
  gameOver = false;
  paused = false;
}

function randomFood() {
  let pos;
  do {
    pos = {
      x: Math.floor(Math.random() * GRID_WIDTH),
      y: Math.floor(Math.random() * GRID_HEIGHT)
    };
  } while (snake.some(seg => seg.x === pos.x && seg.y === pos.y));
  return pos;
}

function drawRect(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
}

function drawText(text, size, x, y, color, center = false) {
  ctx.fillStyle = color;
  ctx.font = `${size}px Consolas`;
  ctx.textAlign = center ? "center" : "left";
  ctx.fillText(text, x, y);
}

function update() {
  if (gameOver || paused) return;

  direction = nextDirection;
  let newHead = {
    x: snake[0].x + direction.x,
    y: snake[0].y + direction.y
  };

  if (wrapMode) {
    newHead.x = (newHead.x + GRID_WIDTH) % GRID_WIDTH;
    newHead.y = (newHead.y + GRID_HEIGHT) % GRID_HEIGHT;
  } else {
    if (newHead.x < 0 || newHead.x >= GRID_WIDTH ||
        newHead.y < 0 || newHead.y >= GRID_HEIGHT) {
      gameOver = true;
      return;
    }
  }

  if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
    gameOver = true;
    return;
  }

  snake.unshift(newHead);

  if (newHead.x === food.x && newHead.y === food.y) {
    score++;
    food = randomFood();
  } else {
    snake.pop();
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawRect(food.x, food.y, "red");

  snake.forEach((seg, i) => {
    drawRect(seg.x, seg.y, i === 0 ? "yellow" : "green");
  });

  drawText(`Score: ${score}`, 20, 8, 20, "white");

  if (paused) {
    drawText("PAUSED", 36, canvas.width / 2, canvas.height / 2, "white", true);
  }

  if (gameOver) {
    drawText("GAME OVER", 40, canvas.width / 2, canvas.height / 2 - 20, "red", true);
    drawText(`Final Score: ${score}`, 28, canvas.width / 2, canvas.height / 2 + 20, "white", true);
    drawText("Press R or A to restart", 22, canvas.width / 2, canvas.height / 2 + 60, "white", true);
  }
}

function gameLoop() {
  handleGamepad();
  update();
  draw();
}

// === Keyboard Controls ===
document.addEventListener("keydown", e => {
  if (e.key === "ArrowLeft" || e.key === "a") {
    if (direction.x !== 1) nextDirection = {x: -1, y: 0};
  } else if (e.key === "ArrowRight" || e.key === "d") {
    if (direction.x !== -1) nextDirection = {x: 1, y: 0};
  } else if (e.key === "ArrowUp" || e.key === "w") {
    if (direction.y !== 1) nextDirection = {x: 0, y: -1};
  } else if (e.key === "ArrowDown" || e.key === "s") {
    if (direction.y !== -1) nextDirection = {x: 0, y: 1};
  } else if (e.key === "p") {
    paused = !paused;
  } else if (e.key === "r") {
    if (gameOver) resetGame();
  }
});

// === Gamepad Controls ===
let lastGamepadInputTime = 0;
function handleGamepad() {
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  const gp = gamepads[0];
  if (!gp) return;

  const now = performance.now();
  if (now - lastGamepadInputTime < 120) return; // limit input speed

  let horizontal = gp.axes[0]; // Left stick X
  let vertical = gp.axes[1];   // Left stick Y
  let dpadUp = gp.buttons[12]?.pressed;
  let dpadDown = gp.buttons[13]?.pressed;
  let dpadLeft = gp.buttons[14]?.pressed;
  let dpadRight = gp.buttons[15]?.pressed;

  if (dpadLeft || horizontal < -0.5) {
    if (direction.x !== 1) nextDirection = {x: -1, y: 0};
    lastGamepadInputTime = now;
  } else if (dpadRight || horizontal > 0.5) {
    if (direction.x !== -1) nextDirection = {x: 1, y: 0};
    lastGamepadInputTime = now;
  } else if (dpadUp || vertical < -0.5) {
    if (direction.y !== 1) nextDirection = {x: 0, y: -1};
    lastGamepadInputTime = now;
  } else if (dpadDown || vertical > 0.5) {
    if (direction.y !== -1) nextDirection = {x: 0, y: 1};
    lastGamepadInputTime = now;
  }

  if (gp.buttons[9]?.pressed) { // Start / Options button
    paused = !paused;
    lastGamepadInputTime = now;
  }
  if (gp.buttons[0]?.pressed && gameOver) { // A / Cross button
    resetGame();
    lastGamepadInputTime = now;
  }
}

resetGame();
setInterval(gameLoop, 1000 / FPS);
</script>

</body>
</html>
