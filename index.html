<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake Game (Controller + Hard Mode + Leaderboard)</title>
<style>
  body {
    background: black;
    margin: 0;
    color: white;
    font-family: Consolas, monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  canvas {
    background: black;
    display: block;
    border: 2px solid white;
    margin-top: 10px;
  }
  .buttons {
    margin: 5px;
  }
  button {
    background: #222;
    color: white;
    border: 1px solid #555;
    padding: 6px 12px;
    margin: 4px;
    font-family: inherit;
    cursor: pointer;
  }
  button:hover {
    background: #333;
  }
  .leaderboard {
    margin-top: 10px;
    text-align: center;
  }
</style>
</head>
<body>

<div class="buttons">
  <button id="toggleMode">Mode: Wrap Around</button>
  <button id="toggleHard">Difficulty: Normal</button>
</div>
<canvas id="game"></canvas>

<div class="leaderboard">
  <h3>Leaderboard</h3>
  <div id="scores"></div>
</div>

<script>
const CELL_SIZE = 20;
const GRID_WIDTH = 32;
const GRID_HEIGHT = 24;
let FPS = 12; // normal
const FPS_HARD = 18; // hard mode speed

const canvas = document.getElementById("game");
canvas.width = CELL_SIZE * GRID_WIDTH;
canvas.height = CELL_SIZE * GRID_HEIGHT;
const ctx = canvas.getContext("2d");

let snake, direction, nextDirection, food, score, gameOver, paused;
let wrapMode = true;
let hardMode = false;
let appleDelayCounter = 0;

document.getElementById("toggleMode").addEventListener("click", () => {
  wrapMode = !wrapMode;
  document.getElementById("toggleMode").textContent =
    `Mode: ${wrapMode ? "Wrap Around" : "Walls Kill"}`;
  resetGame();
});

document.getElementById("toggleHard").addEventListener("click", () => {
  hardMode = !hardMode;
  document.getElementById("toggleHard").textContent =
    `Difficulty: ${hardMode ? "Hard" : "Normal"}`;
  FPS = hardMode ? FPS_HARD : 12;
  resetGame();
});

function resetGame() {
  const startX = Math.floor(GRID_WIDTH / 2);
  const startY = Math.floor(GRID_HEIGHT / 2);
  snake = [
    {x: startX, y: startY},
    {x: startX - 1, y: startY},
    {x: startX - 2, y: startY}
  ];
  direction = {x: 1, y: 0};
  nextDirection = {x: 1, y: 0};
  food = randomFood();
  score = 0;
  gameOver = false;
  paused = false;
  appleDelayCounter = 0;
}

function randomFood() {
  let pos;
  do {
    pos = {
      x: Math.floor(Math.random() * GRID_WIDTH),
      y: Math.floor(Math.random() * GRID_HEIGHT)
    };
  } while (snake.some(seg => seg.x === pos.x && seg.y === pos.y));
  return pos;
}

function drawRect(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
}

function drawText(text, size, x, y, color, center = false) {
  ctx.fillStyle = color;
  ctx.font = `${size}px Consolas`;
  ctx.textAlign = center ? "center" : "left";
  ctx.fillText(text, x, y);
}

function update() {
  if (gameOver || paused) return;

  direction = nextDirection;
  let newHead = {
    x: snake[0].x + direction.x,
    y: snake[0].y + direction.y
  };

  if (wrapMode) {
    newHead.x = (newHead.x + GRID_WIDTH) % GRID_WIDTH;
    newHead.y = (newHead.y + GRID_HEIGHT) % GRID_HEIGHT;
  } else {
    if (newHead.x < 0 || newHead.x >= GRID_WIDTH ||
        newHead.y < 0 || newHead.y >= GRID_HEIGHT) {
      endGame();
      return;
    }
  }

  if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
    endGame();
    return;
  }

  snake.unshift(newHead);

  if (food && newHead.x === food.x && newHead.y === food.y) {
    score++;
    food = null; // remove apple
    appleDelayCounter = hardMode ? 5 : 0; // delay before new apple in hard mode
  } else {
    snake.pop();
  }

  if (!food && appleDelayCounter > 0) {
    appleDelayCounter--;
    if (appleDelayCounter === 0) {
      food = randomFood();
    }
  } else if (!food && appleDelayCounter === 0) {
    food = randomFood();
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (food) drawRect(food.x, food.y, "red");
  snake.forEach((seg, i) => {
    drawRect(seg.x, seg.y, i === 0 ? "yellow" : "green");
  });

  drawText(`Score: ${score}`, 20, 8, 20, "white");

  if (paused) {
    drawText("PAUSED", 36, canvas.width / 2, canvas.height / 2, "white", true);
  }

  if (gameOver) {
    drawText("GAME OVER", 40, canvas.width / 2, canvas.height / 2 - 20, "red", true);
    drawText(`Final Score: ${score}`, 28, canvas.width / 2, canvas.height / 2 + 20, "white", true);
    drawText("Press R or A to restart", 22, canvas.width / 2, canvas.height / 2 + 60, "white", true);
  }
}

function endGame() {
  gameOver = true;
  saveScore();
  renderLeaderboard();
}

// === Leaderboard ===
function saveScore() {
  let modeKey = hardMode ? "hard" : "normal";
  let scores = JSON.parse(localStorage.getItem(`snake_scores_${modeKey}`) || "[]");
  scores.push(score);
  scores.sort((a, b) => b - a);
  scores = scores.slice(0, 5); // keep top 5
  localStorage.setItem(`snake_scores_${modeKey}`, JSON.stringify(scores));
}

function renderLeaderboard() {
  let html = "";
  ["normal", "hard"].forEach(mode => {
    let scores = JSON.parse(localStorage.getItem(`snake_scores_${mode}`) || "[]");
    html += `<strong>${mode.toUpperCase()} MODE</strong><br>`;
    if (scores.length === 0) {
      html += "(no scores yet)<br>";
    } else {
      scores.forEach((s, i) => {
        html += `${i + 1}. ${s}<br>`;
      });
    }
    html += "<br>";
  });
  document.getElementById("scores").innerHTML = html;
}

// === Keyboard Controls ===
document.addEventListener("keydown", e => {
  if (e.key === "ArrowLeft" || e.key === "a") {
    if (direction.x !== 1) nextDirection = {x: -1, y: 0};
  } else if (e.key === "ArrowRight" || e.key === "d") {
    if (direction.x !== -1) nextDirection = {x: 1, y: 0};
  } else if (e.key === "ArrowUp" || e.key === "w") {
    if (direction.y !== 1) nextDirection = {x: 0, y: -1};
  } else if (e.key === "ArrowDown" || e.key === "s") {
    if (direction.y !== -1) nextDirection = {x: 0, y: 1};
  } else if (e.key === "p") {
    paused = !paused;
  } else if (e.key === "r") {
    if (gameOver) resetGame();
  }
});

// === Gamepad Controls ===
let lastGamepadInputTime = 0;
function handleGamepad() {
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  const gp = gamepads[0];
  if (!gp) return;

  const now = performance.now();
  if (now - lastGamepadInputTime < 120) return;

  let horizontal = gp.axes[0];
  let vertical = gp.axes[1];
  let dpadUp = gp.buttons[12]?.pressed;
  let dpadDown = gp.buttons[13]?.pressed;
  let dpadLeft = gp.buttons[14]?.pressed;
  let dpadRight = gp.buttons[15]?.pressed;

  if (dpadLeft || horizontal < -0.5) {
    if (direction.x !== 1) nextDirection = {x: -1, y: 0};
    lastGamepadInputTime = now;
  } else if (dpadRight || horizontal > 0.5) {
    if (direction.x !== -1) nextDirection = {x: 1, y: 0};
    lastGamepadInputTime = now;
  } else if (dpadUp || vertical < -0.5) {
    if (direction.y !== 1) nextDirection = {x: 0, y: -1};
    lastGamepadInputTime = now;
  } else if (dpadDown || vertical > 0.5) {
    if (direction.y !== -1) nextDirection = {x: 0, y: 1};
    lastGamepadInputTime = now;
  }

  if (gp.buttons[9]?.pressed) { // Start button
    paused = !paused;
    lastGamepadInputTime = now;
  }
  if (gp.buttons[0]?.pressed && gameOver) { // A button
    resetGame();
    lastGamepadInputTime = now;
  }
}

function gameLoop() {
  handleGamepad();
  update();
  draw();
}

resetGame();
renderLeaderboard();
setInterval(gameLoop, 1000 / FPS);
</script>

</body>
</html>
